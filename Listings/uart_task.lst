C51 COMPILER V9.54   UART_TASK                                                             04/28/2017 13:06:00 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART_TASK
OBJECT MODULE PLACED IN .\Objects\uart_task.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE task\uart\uart_task.c OMF2 OPTIMIZE(8,SPEED) BROWSE DEBUG PRINT(.\Listin
                    -gs\uart_task.lst) OBJECT(.\Objects\uart_task.obj)

line level    source

   1          #include "task/uart/uart_task.h"
   2          
   3          /* UART2 */
   4          extern xdata  Byte     recv2_buf[MAX_RecvFrame];             // receiving buffer
   5          extern xdata  Byte     recv2_state;                          // receive state
   6          extern xdata  Byte     recv2_timer;                          // receive time-out, ÓÃÓÚ×Ö½Ú¼ä³¬Ê±ÅÐ¶¨
   7          extern xdata  Byte     recv2_chksum;                         // computed checksum
   8          extern xdata  Byte     recv2_ctr;                            // reveiving pointer
   9          
  10          extern xdata  Byte     trans2_buf[MAX_TransFrame];           // uart transfer message buffer
  11          extern xdata  Byte     trans2_ctr;                           // transfer pointer
  12          extern xdata  Byte     trans2_size;                          // transfer bytes number
  13          extern xdata  Byte     trans2_chksum;                        // computed check-sum of already transfered m
             -essage
  14          
  15          extern xdata  Byte     uart2_q_index;                        // ÕýÔÚ·¢ËÍÄ³¶ÓÁÐÏîµÄÐòºÅ£ºÈôÎª0xFF, ±íÊ¾Ã»ÓÐ
             -ÈÎºÎÏî½øÈë·¢ËÍÁ÷³Ì
  16          extern xdata  sUART_Q  uart2_send_queue[UART_QUEUE_NUM];     // ´®¿Ú·¢ËÍ¶ÓÁÐ
  17          extern xdata  sUART_Q  uart2_recv_queue[UART_QUEUE_NUM];     // ´®¿Ú½ÓÊÕ¶ÓÁÐ
  18          
  19          /* System */
  20          extern data   Uint16   gl_ack_tick;                              //ÉÏÎ»»ú485¿ÚÓ¦´ðÑÓÊ±¼ÆÊ± tick
  21          extern data   Byte     gl_comm_addr;                         //RS485Í¨ÐÅµØÖ·
  22          extern data   Byte     gl_reply_tick;                        //ÉèÖÃ·µ»ØÑÓÊ±
  23          extern data   Byte     watch_dog_tick;
  24          
  25          /* AD sample */
  26          extern data   Byte     ad_alarm_exts;                        //±¨¾¯±êÖ¾£º00-ÎÞ±¨¾¯,01-1#·ÀÇø±¨¾¯£¬02-2#·ÀÇ
             -ø±¨¾¯£¬03-1#·ÀÇøºÍ2#·ÀÇøÍ¬Ê±±¨¾¯
  27          
  28          
  29          void uart_task_init(void)
  30          {
  31   1              Byte i;
  32   1      
  33   1              //uart2Ïà¹Ø±äÁ¿³õÊ¼»¯
  34   1              recv2_state    = FSA_INIT;
  35   1              recv2_timer    = 0;
  36   1              recv2_ctr      = 0;
  37   1              recv2_chksum   = 0;
  38   1      
  39   1              trans2_size    = 0;
  40   1              trans2_ctr     = 0;
  41   1      
  42   1              for (i = 0; i < UART_QUEUE_NUM; i++) {
  43   2                      uart2_send_queue[i].flag = 0; //¾ù¿ÕÏÐ
  44   2                      uart2_recv_queue[i].flag = 0; //¾ù¿ÕÏÐ
  45   2              }
  46   1              uart2_q_index = 0xFF;             //ÎÞ¶ÓÁÐÏî½øÈë·¢ËÍÁ÷³Ì
  47   1      
  48   1              //UARTÓ²¼þ³õÊ¼»¯
  49   1              uart_init();                      //ÒÑ¾­×¼±¸ºÃ´®¿ÚÊÕ·¢£¬Ö»ÊÇ»¹Î´Ê¹ÄÜÈ«¾ÖÖÐ¶Ï
  50   1      }
  51          
C51 COMPILER V9.54   UART_TASK                                                             04/28/2017 13:06:00 PAGE 2   

  52          void uart_task(void)
  53          {
  54   1              Byte i,j;
  55   1              Byte *ptr;
  56   1              
  57   1              //1. UART2 ¶ÓÁÐ´¦Àí
  58   1              //ÕÒÊÇ·ñÓÐµÈ´ý´¦ÀíµÄÏî
  59   1              for (j = 0; j < UART_QUEUE_NUM; j++) {
  60   2                      if (uart2_recv_queue[j].flag == 1) {//ÓÐµÈ´ý´¦ÀíµÄÏî
  61   3                              ptr = uart2_recv_queue[j].tdata;
  62   3                              
  63   3                              //ÊÇ·ñÐèÒªÖ´ÐÐ±¾ÃüÁî
  64   3                              if ((ptr[0] == CMD_ADDR_BC) || (ptr[0] == gl_comm_addr)) {
  65   4                                      //¹ã²¥µØÖ·»òÖ¸¶¨±¾Éè±¸, ÐèÒªÖ´ÐÐ
  66   4                                      switch (ptr[3])
  67   4                                      {
  68   5                                      case CMD_DADDR_qSTAT://Ñ¯ÎÊ·ÀÇø×´Ì¬ - ±¨¸æ¸øÉÏÎ»»ú
  69   5                                              //ÔÚUART2·¢ËÍ¶ÓÁÐÖÐÕÒ¿ÕÏÐBuffer
  70   5                                              i = uart2_get_send_buffer();
  71   5                                              if (i < UART_QUEUE_NUM) {
  72   6                                                      //ÕÒµ½ÁË¿ÕÏÐbuffer, ×¼±¸Ó¦´ð                                    
  73   6                                                      uart2_send_queue[i].tdata[0] = FRAME_STX;              //Ö¡Í·
  74   6                                                      uart2_send_queue[i].tdata[1] = ptr[1];             //Ä¿µÄµØÖ·
  75   6                                                      uart2_send_queue[i].tdata[2] = gl_comm_addr;       //Ô´µØÖ·
  76   6                                                      if (gl_comm_addr == CMD_ADDR_UNSOLV) {             //±¾Éè±¸ÎÞÓÐÐ§µØÖ·
  77   7                                                              //Ö»»Ø²ÎÊýÓ¦´ð
  78   7                                                              uart2_send_queue[i].tdata[3] = 1;
  79   7                                                              uart2_send_queue[i].tdata[4] = CMD_DADDR_aPARA;
  80   7                                                              uart2_send_queue[i].len = 6;
  81   7                                                      } else { //ÓÐÓÐÐ§µØÖ·,»Ø·ÀÇø×´Ì¬
  82   7                                                              if ((ad_alarm_exts & 0x03) == 0x00) { //2¸ö·ÀÇø¾ùÎÞ±¨¾¯
  83   8                                                                      uart2_send_queue[i].tdata[3] = 1;
  84   8                                                                      uart2_send_queue[i].tdata[4] = CMD_ACK_OK;
  85   8                                                                      uart2_send_queue[i].len = 6;
  86   8                                                              } else { //ÓÐ±¨¾¯
  87   8                                                                      uart2_send_queue[i].tdata[3] = 2;
  88   8                                                                      uart2_send_queue[i].tdata[4] = CMD_DADDR_aSTAT;
  89   8                                                                      uart2_send_queue[i].tdata[5] = (ad_alarm_exts & 0x03);
  90   8                                                                      uart2_send_queue[i].len = 7;
  91   8                                                              }
  92   7                                                      }
  93   6                                              }
  94   5                                              
  95   5                                              break;
  96   5      
  97   5                                      case CMD_DADDR_qPARA://Ñ¯ÎÊµØÖ·- ±¨¸æ¸øÉÏÎ»»ú
  98   5                                              //ÔÚUART2·¢ËÍ¶ÓÁÐÖÐÕÒ¿ÕÏÐBuffer
  99   5                                              i = uart2_get_send_buffer();
 100   5                                              if (i < UART_QUEUE_NUM) {
 101   6                                                      //ÕÒµ½ÁË¿ÕÏÐbuffer, ×¼±¸Ó¦´ð                                    
 102   6                                                      uart2_send_queue[i].tdata[0] = FRAME_STX;                      //Ö¡Í·
 103   6                                                      uart2_send_queue[i].tdata[1] = ptr[1];                     //Ä¿µÄµØÖ·
 104   6                                                      uart2_send_queue[i].tdata[2] = gl_comm_addr;               //Ô´µØÖ·
 105   6                                                      uart2_send_queue[i].tdata[3] = 1;                          //ÃüÁî³¤¶È
 106   6                                                      uart2_send_queue[i].tdata[4] = CMD_DADDR_aPARA;            //ÃüÁîID
 107   6                                                      uart2_send_queue[i].len = 6;
 108   6                                              }
 109   5                                              
 110   5                                              break;
 111   5                                              
 112   5                                      case 0xE3://ÉèÖÃÑÓÊ±Ê±¼ä
 113   5                          //1. Ð´Èëflash
C51 COMPILER V9.54   UART_TASK                                                             04/28/2017 13:06:00 PAGE 3   

 114   5                          flash_enable();                              
 115   5                          flash_erase(EEPROM_SECTOR1);                                        
 116   5                          flash_write(ptr[4], EEPROM_SECTOR1 + 1);  
 117   5                          flash_write(0x5a, EEPROM_SECTOR1);                                                    
             -          
 118   5                          flash_disable();
 119   5      
 120   5                          //2. ¸üÐÂ±äÁ¿
 121   5                          gl_reply_tick = ptr[4];
 122   5                                      
 123   5                          break;
 124   5      
 125   5                      case 0xE4://¶ÁÈ¡ÑÓÊ±Ê±¼ä
 126   5                          //ÔÚUART3¶ÓÁÐÖÐÕÒ¿ÕÏÐBuffer
 127   5                          i = uart2_get_send_buffer();
 128   5                          if (i < UART_QUEUE_NUM) { //ÕÒµ½ÁË¿ÕÏÐbuffer, ×¼±¸Ó¦´ð                       
 129   6                              uart2_send_queue[i].tdata[0] = FRAME_STX;                          //Ö¡Í·
 130   6                              uart2_send_queue[i].tdata[1] = ptr[1];                         //Ä¿µÄµØÖ·
 131   6                              uart2_send_queue[i].tdata[2] = gl_comm_addr;                   //Ô´µØÖ·                                                                                                         
             -                 
 132   6                              uart2_send_queue[i].tdata[3] = 2;
 133   6                              uart2_send_queue[i].tdata[4] = 0xF4;
 134   6                              uart2_send_queue[i].tdata[5] = gl_reply_tick;
 135   6                              uart2_send_queue[i].len = 7;                                                                                                            
 136   6                          }
 137   5                          
 138   5                          break;      
 139   5                                      }
 140   4                                      
 141   4                                      //ÉèÖÃÓ¦´ðÑÓÊ±
 142   4                      Disable_interrupt();
 143   4                      //gl_ack_tick = gl_comm_addr - 15;
 144   4                                      gl_ack_tick = (Uint16)(REPLY_DLY + (Uint16)((gl_comm_addr - 16) * gl_reply_tick) / SCHEDULER_TICK);
 145   4      
 146   4                                      // ÖØ×°³õÖµ
 147   4                                      TR0 = 0;
 148   4                                      TL0 = 0x00;                                           // ÉèÖÃ¶¨Ê±³õÖµ
 149   4                                      TH0 = 0xDC;                                           // ÉèÖÃ¶¨Ê±³õÖµ
 150   4                                      //TH0 = 0x28;                                     // ÉèÖÃ¶¨Ê±³õÖµ
 151   4                                      TR0 = 1;                                              // ¶¨Ê±Æ÷0¿ªÊ¼¼ÆÊ±
 152   4                                      
 153   4                      Enable_interrupt();
 154   4                              }
 155   3      
 156   3                              //´¦ÀíÍê³É,ÊÍ·Å¸Ã¶ÓÁÐÏî
 157   3                              uart2_recv_queue[j].flag = 0;
 158   3                              break;
 159   3                      }
 160   2              }
 161   1      
 162   1              //2. UART2 ¶ÓÁÐ·¢ËÍ
 163   1              if ((uart2_q_index == 0xFF) && (recv2_state == FSA_INIT)) {
 164   2                      //UART2ÎÞ½øÈë·¢ËÍÁ÷³ÌµÄ¶ÓÁÐÏî, ÕÒÊÇ·ñÓÐµÈ´ý·¢ËÍµÄÏî
 165   2                      for (i = 0; i < UART_QUEUE_NUM; i++) {
 166   3                              if ((uart2_send_queue[i].flag == 1) && (gl_ack_tick == 0)) {
 167   4                                      //ÖØÐÂ¸³Öµ
 168   4                                      //watch_dog_tick = 0xFF;
 169   4                                      
 170   4                                      //ÓÐµÈ´ý·¢ËÍµÄÏî£¬°²ÅÅ´ËÏî·¢ËÍ
 171   4                                      uart2_send_queue[i].flag = 2;
 172   4                                      uart2_q_index = i;
 173   4                                      memcpy(trans2_buf, uart2_send_queue[i].tdata, uart2_send_queue[i].len - 1);
C51 COMPILER V9.54   UART_TASK                                                             04/28/2017 13:06:00 PAGE 4   

 174   4                                      trans2_size = uart2_send_queue[i].len;
 175   4                                      uart2_start_trans();
 176   4                                      break;
 177   4                              }
 178   3                      }
 179   2              }
 180   1      }
 181          
 182          /***************************************************************************
 183          * NAME: uart2_get_send_buffer
 184          *----------------------------------------------------------------------------
 185          * PARAMS:
 186          * return: Byte
 187          *         Èô·µ»ØÖµ >= UART_QUEUE_NUM, Ôò±íÊ¾Ã»ÓÐÉêÇëµ½¿ÕÏÐbuffer
 188          *----------------------------------------------------------------------------
 189          * PURPOSE: ÔÚ´®¿Ú2¶ÓÁÐÖÐÑ°ÕÒ¿ÕÏÐ¶ÓÁÐÏî£¬ÈôÕÒµ½£¬·µ»Ø¶ÓÁÐÏîÐòºÅ(0 ~ (UART_QUEUE_NUM-1))
 190          *****************************************************************************/
 191          Byte uart2_get_send_buffer(void)
 192          {
 193   1              Byte i, flag;
 194   1      
 195   1              for (i = 0; i < UART_QUEUE_NUM; i++) {
 196   2                      Disable_interrupt();
 197   2                      flag = uart2_send_queue[i].flag;
 198   2                      Enable_interrupt();
 199   2                      if (flag == 0) {  //ÒÑÕÒµ½¿ÕÏÐBuffer
 200   3                              uart2_send_queue[i].flag = 1;
 201   3                              break;
 202   3                      }
 203   2              }
 204   1              return i;
 205   1      }
 206          
 207          /***************************************************************************
 208          * NAME: uart2_get_recv_buffer
 209          *----------------------------------------------------------------------------
 210          * PARAMS:
 211          * return: Byte
 212          *         Èô·µ»ØÖµ >= UART_QUEUE_NUM, Ôò±íÊ¾Ã»ÓÐÉêÇëµ½¿ÕÏÐbuffer
 213          *----------------------------------------------------------------------------
 214          * PURPOSE: ÔÚ´®¿Ú2¶ÓÁÐÖÐÑ°ÕÒ¿ÕÏÐ¶ÓÁÐÏî£¬ÈôÕÒµ½£¬·µ»Ø¶ÓÁÐÏîÐòºÅ(0 ~ (UART_QUEUE_NUM-1))
 215          *****************************************************************************/
 216          Byte uart2_get_recv_buffer(void)
 217          {
 218   1              Byte i, flag;
 219   1      
 220   1              for (i = 0; i < UART_QUEUE_NUM; i++) {
 221   2                      Disable_interrupt();
 222   2                      flag = uart2_recv_queue[i].flag;
 223   2                      Enable_interrupt();
 224   2                      if (flag == 0) {  //ÒÑÕÒµ½¿ÕÏÐBuffer
 225   3                              uart2_recv_queue[i].flag = 1;
 226   3                              break;
 227   3                      }
 228   2              }
 229   1              return i;
 230   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1062    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.54   UART_TASK                                                             04/28/2017 13:06:00 PAGE 5   

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
