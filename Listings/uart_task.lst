C51 COMPILER V9.54   UART_TASK                                                             04/28/2017 13:06:00 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART_TASK
OBJECT MODULE PLACED IN .\Objects\uart_task.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE task\uart\uart_task.c OMF2 OPTIMIZE(8,SPEED) BROWSE DEBUG PRINT(.\Listin
                    -gs\uart_task.lst) OBJECT(.\Objects\uart_task.obj)

line level    source

   1          #include "task/uart/uart_task.h"
   2          
   3          /* UART2 */
   4          extern xdata  Byte     recv2_buf[MAX_RecvFrame];             // receiving buffer
   5          extern xdata  Byte     recv2_state;                          // receive state
   6          extern xdata  Byte     recv2_timer;                          // receive time-out, ”√”⁄◊÷Ω⁄º‰≥¨ ±≈–∂®
   7          extern xdata  Byte     recv2_chksum;                         // computed checksum
   8          extern xdata  Byte     recv2_ctr;                            // reveiving pointer
   9          
  10          extern xdata  Byte     trans2_buf[MAX_TransFrame];           // uart transfer message buffer
  11          extern xdata  Byte     trans2_ctr;                           // transfer pointer
  12          extern xdata  Byte     trans2_size;                          // transfer bytes number
  13          extern xdata  Byte     trans2_chksum;                        // computed check-sum of already transfered m
             -essage
  14          
  15          extern xdata  Byte     uart2_q_index;                        // ’˝‘⁄∑¢ÀÕƒ≥∂”¡–œÓµƒ–Ú∫≈£∫»ÙŒ™0xFF, ±Ì æ√ª”–
             -»Œ∫ŒœÓΩ¯»Î∑¢ÀÕ¡˜≥Ã
  16          extern xdata  sUART_Q  uart2_send_queue[UART_QUEUE_NUM];     // ¥Æø⁄∑¢ÀÕ∂”¡–
  17          extern xdata  sUART_Q  uart2_recv_queue[UART_QUEUE_NUM];     // ¥Æø⁄Ω” ’∂”¡–
  18          
  19          /* System */
  20          extern data   Uint16   gl_ack_tick;                              //…œŒªª˙485ø⁄”¶¥—” ±º∆ ± tick
  21          extern data   Byte     gl_comm_addr;                         //RS485Õ®–≈µÿ÷∑
  22          extern data   Byte     gl_reply_tick;                        //…Ë÷√∑µªÿ—” ±
  23          extern data   Byte     watch_dog_tick;
  24          
  25          /* AD sample */
  26          extern data   Byte     ad_alarm_exts;                        //±®æØ±Í÷æ£∫00-Œﬁ±®æØ,01-1#∑¿«¯±®æØ£¨02-2#∑¿«
             -¯±®æØ£¨03-1#∑¿«¯∫Õ2#∑¿«¯Õ¨ ±±®æØ
  27          
  28          
  29          void uart_task_init(void)
  30          {
  31   1              Byte i;
  32   1      
  33   1              //uart2œ‡πÿ±‰¡ø≥ı ºªØ
  34   1              recv2_state    = FSA_INIT;
  35   1              recv2_timer    = 0;
  36   1              recv2_ctr      = 0;
  37   1              recv2_chksum   = 0;
  38   1      
  39   1              trans2_size    = 0;
  40   1              trans2_ctr     = 0;
  41   1      
  42   1              for (i = 0; i < UART_QUEUE_NUM; i++) {
  43   2                      uart2_send_queue[i].flag = 0; //æ˘ø’œ–
  44   2                      uart2_recv_queue[i].flag = 0; //æ˘ø’œ–
  45   2              }
  46   1              uart2_q_index = 0xFF;             //Œﬁ∂”¡–œÓΩ¯»Î∑¢ÀÕ¡˜≥Ã
  47   1      
  48   1              //UART”≤º˛≥ı ºªØ
  49   1              uart_init();                      //“—æ≠◊º±∏∫√¥Æø⁄ ’∑¢£¨÷ª «ªπŒ¥ πƒ‹»´æ÷÷–∂œ
  50   1      }
  51          
C51 COMPILER V9.54   UART_TASK                                                             04/28/2017 13:06:00 PAGE 2   

  52          void uart_task(void)
  53          {
  54   1              Byte i,j;
  55   1              Byte *ptr;
  56   1              
  57   1              //1. UART2 ∂”¡–¥¶¿Ì
  58   1              //’“ «∑Ò”–µ»¥˝¥¶¿ÌµƒœÓ
  59   1              for (j = 0; j < UART_QUEUE_NUM; j++) {
  60   2                      if (uart2_recv_queue[j].flag == 1) {//”–µ»¥˝¥¶¿ÌµƒœÓ
  61   3                              ptr = uart2_recv_queue[j].tdata;
  62   3                              
  63   3                              // «∑Ò–Ë“™÷¥––±æ√¸¡Ó
  64   3                              if ((ptr[0] == CMD_ADDR_BC) || (ptr[0] == gl_comm_addr)) {
  65   4                                      //π„≤•µÿ÷∑ªÚ÷∏∂®±æ…Ë±∏, –Ë“™÷¥––
  66   4                                      switch (ptr[3])
  67   4                                      {
  68   5                                      case CMD_DADDR_qSTAT://—ØŒ ∑¿«¯◊¥Ã¨ - ±®∏Ê∏¯…œŒªª˙
  69   5                                              //‘⁄UART2∑¢ÀÕ∂”¡–÷–’“ø’œ–Buffer
  70   5                                              i = uart2_get_send_buffer();
  71   5                                              if (i < UART_QUEUE_NUM) {
  72   6                                                      //’“µΩ¡Àø’œ–buffer, ◊º±∏”¶¥                                    
  73   6                                                      uart2_send_queue[i].tdata[0] = FRAME_STX;              //÷°Õ∑
  74   6                                                      uart2_send_queue[i].tdata[1] = ptr[1];             //ƒøµƒµÿ÷∑
  75   6                                                      uart2_send_queue[i].tdata[2] = gl_comm_addr;       //‘¥µÿ÷∑
  76   6                                                      if (gl_comm_addr == CMD_ADDR_UNSOLV) {             //±æ…Ë±∏Œﬁ”––ßµÿ÷∑
  77   7                                                              //÷ªªÿ≤Œ ˝”¶¥
  78   7                                                              uart2_send_queue[i].tdata[3] = 1;
  79   7                                                              uart2_send_queue[i].tdata[4] = CMD_DADDR_aPARA;
  80   7                                                              uart2_send_queue[i].len = 6;
  81   7                                                      } else { //”–”––ßµÿ÷∑,ªÿ∑¿«¯◊¥Ã¨
  82   7                                                              if ((ad_alarm_exts & 0x03) == 0x00) { //2∏ˆ∑¿«¯æ˘Œﬁ±®æØ
  83   8                                                                      uart2_send_queue[i].tdata[3] = 1;
  84   8                                                                      uart2_send_queue[i].tdata[4] = CMD_ACK_OK;
  85   8                                                                      uart2_send_queue[i].len = 6;
  86   8                                                              } else { //”–±®æØ
  87   8                                                                      uart2_send_queue[i].tdata[3] = 2;
  88   8                                                                      uart2_send_queue[i].tdata[4] = CMD_DADDR_aSTAT;
  89   8                                                                      uart2_send_queue[i].tdata[5] = (ad_alarm_exts & 0x03);
  90   8                                                                      uart2_send_queue[i].len = 7;
  91   8                                                              }
  92   7                                                      }
  93   6                                              }
  94   5                                              
  95   5                                              break;
  96   5      
  97   5                                      case CMD_DADDR_qPARA://—ØŒ µÿ÷∑- ±®∏Ê∏¯…œŒªª˙
  98   5                                              //‘⁄UART2∑¢ÀÕ∂”¡–÷–’“ø’œ–Buffer
  99   5                                              i = uart2_get_send_buffer();
 100   5                                              if (i < UART_QUEUE_NUM) {
 101   6                                                      //’“µΩ¡Àø’œ–buffer, ◊º±∏”¶¥                                    
 102   6                                                      uart2_send_queue[i].tdata[0] = FRAME_STX;                      //÷°Õ∑
 103   6                                                      uart2_send_queue[i].tdata[1] = ptr[1];                     //ƒøµƒµÿ÷∑
 104   6                                                      uart2_send_queue[i].tdata[2] = gl_comm_addr;               //‘¥µÿ÷∑
 105   6                                                      uart2_send_queue[i].tdata[3] = 1;                          //√¸¡Ó≥§∂»
 106   6                                                      uart2_send_queue[i].tdata[4] = CMD_DADDR_aPARA;            //√¸¡ÓID
 107   6                                                      uart2_send_queue[i].len = 6;
 108   6                                              }
 109   5                                              
 110   5                                              break;
 111   5                                              
 112   5                                      case 0xE3://…Ë÷√—” ± ±º‰
 113   5                          //1. –¥»Îflash
C51 COMPILER V9.54   UART_TASK                                                             04/28/2017 13:06:00 PAGE 3   

 114   5                          flash_enable();                              
 115   5                          flash_erase(EEPROM_SECTOR1);                                        
 116   5                          flash_write(ptr[4], EEPROM_SECTOR1 + 1);  
 117   5                          flash_write(0x5a, EEPROM_SECTOR1);                                                    
             -          
 118   5                          flash_disable();
 119   5      
 120   5                          //2. ∏¸–¬±‰¡ø
 121   5                          gl_reply_tick = ptr[4];
 122   5                                      
 123   5                          break;
 124   5      
 125   5                      case 0xE4://∂¡»°—” ± ±º‰
 126   5                          //‘⁄UART3∂”¡–÷–’“ø’œ–Buffer
 127   5                          i = uart2_get_send_buffer();
 128   5                          if (i < UART_QUEUE_NUM) { //’“µΩ¡Àø’œ–buffer, ◊º±∏”¶¥                       
 129   6                              uart2_send_queue[i].tdata[0] = FRAME_STX;                          //÷°Õ∑
 130   6                              uart2_send_queue[i].tdata[1] = ptr[1];                         //ƒøµƒµÿ÷∑
 131   6                              uart2_send_queue[i].tdata[2] = gl_comm_addr;                   //‘¥µÿ÷∑                                                                                                         
             -                 
 132   6                              uart2_send_queue[i].tdata[3] = 2;
 133   6                              uart2_send_queue[i].tdata[4] = 0xF4;
 134   6                              uart2_send_queue[i].tdata[5] = gl_reply_tick;
 135   6                              uart2_send_queue[i].len = 7;                                                                                                            
 136   6                          }
 137   5                          
 138   5                          break;      
 139   5                                      }
 140   4                                      
 141   4                                      //…Ë÷√”¶¥—” ±
 142   4                      Disable_interrupt();
 143   4                      //gl_ack_tick = gl_comm_addr - 15;
 144   4                                      gl_ack_tick = (Uint16)(REPLY_DLY + (Uint16)((gl_comm_addr - 16) * gl_reply_tick) / SCHEDULER_TICK);
 145   4      
 146   4                                      // ÷ÿ◊∞≥ı÷µ
 147   4                                      TR0 = 0;
 148   4                                      TL0 = 0x00;                                           // …Ë÷√∂® ±≥ı÷µ
 149   4                                      TH0 = 0xDC;                                           // …Ë÷√∂® ±≥ı÷µ
 150   4                                      //TH0 = 0x28;                                     // …Ë÷√∂® ±≥ı÷µ
 151   4                                      TR0 = 1;                                              // ∂® ±∆˜0ø™ ºº∆ ±
 152   4                                      
 153   4                      Enable_interrupt();
 154   4                              }
 155   3      
 156   3                              //¥¶¿ÌÕÍ≥…, Õ∑≈∏√∂”¡–œÓ
 157   3                              uart2_recv_queue[j].flag = 0;
 158   3                              break;
 159   3                      }
 160   2              }
 161   1      
 162   1              //2. UART2 ∂”¡–∑¢ÀÕ
 163   1              if ((uart2_q_index == 0xFF) && (recv2_state == FSA_INIT)) {
 164   2                      //UART2ŒﬁΩ¯»Î∑¢ÀÕ¡˜≥Ãµƒ∂”¡–œÓ, ’“ «∑Ò”–µ»¥˝∑¢ÀÕµƒœÓ
 165   2                      for (i = 0; i < UART_QUEUE_NUM; i++) {
 166   3                              if ((uart2_send_queue[i].flag == 1) && (gl_ack_tick == 0)) {
 167   4                                      //÷ÿ–¬∏≥÷µ
 168   4                                      //watch_dog_tick = 0xFF;
 169   4                                      
 170   4                                      //”–µ»¥˝∑¢ÀÕµƒœÓ£¨∞≤≈≈¥ÀœÓ∑¢ÀÕ
 171   4                                      uart2_send_queue[i].flag = 2;
 172   4                                      uart2_q_index = i;
 173   4                                      memcpy(trans2_buf, uart2_send_queue[i].tdata, uart2_send_queue[i].len - 1);
C51 COMPILER V9.54   UART_TASK                                                             04/28/2017 13:06:00 PAGE 4   

 174   4                                      trans2_size = uart2_send_queue[i].len;
 175   4                                      uart2_start_trans();
 176   4                                      break;
 177   4                              }
 178   3                      }
 179   2              }
 180   1      }
 181          
 182          /***************************************************************************
 183          * NAME: uart2_get_send_buffer
 184          *----------------------------------------------------------------------------
 185          * PARAMS:
 186          * return: Byte
 187          *         »Ù∑µªÿ÷µ >= UART_QUEUE_NUM, ‘Ú±Ì æ√ª”–…Í«ÎµΩø’œ–buffer
 188          *----------------------------------------------------------------------------
 189          * PURPOSE: ‘⁄¥Æø⁄2∂”¡–÷–—∞’“ø’œ–∂”¡–œÓ£¨»Ù’“µΩ£¨∑µªÿ∂”¡–œÓ–Ú∫≈(0 ~ (UART_QUEUE_NUM-1))
 190          *****************************************************************************/
 191          Byte uart2_get_send_buffer(void)
 192          {
 193   1              Byte i, flag;
 194   1      
 195   1              for (i = 0; i < UART_QUEUE_NUM; i++) {
 196   2                      Disable_interrupt();
 197   2                      flag = uart2_send_queue[i].flag;
 198   2                      Enable_interrupt();
 199   2                      if (flag == 0) {  //“—’“µΩø’œ–Buffer
 200   3                              uart2_send_queue[i].flag = 1;
 201   3                              break;
 202   3                      }
 203   2              }
 204   1              return i;
 205   1      }
 206          
 207          /***************************************************************************
 208          * NAME: uart2_get_recv_buffer
 209          *----------------------------------------------------------------------------
 210          * PARAMS:
 211          * return: Byte
 212          *         »Ù∑µªÿ÷µ >= UART_QUEUE_NUM, ‘Ú±Ì æ√ª”–…Í«ÎµΩø’œ–buffer
 213          *----------------------------------------------------------------------------
 214          * PURPOSE: ‘⁄¥Æø⁄2∂”¡–÷–—∞’“ø’œ–∂”¡–œÓ£¨»Ù’“µΩ£¨∑µªÿ∂”¡–œÓ–Ú∫≈(0 ~ (UART_QUEUE_NUM-1))
 215          *****************************************************************************/
 216          Byte uart2_get_recv_buffer(void)
 217          {
 218   1              Byte i, flag;
 219   1      
 220   1              for (i = 0; i < UART_QUEUE_NUM; i++) {
 221   2                      Disable_interrupt();
 222   2                      flag = uart2_recv_queue[i].flag;
 223   2                      Enable_interrupt();
 224   2                      if (flag == 0) {  //“—’“µΩø’œ–Buffer
 225   3                              uart2_recv_queue[i].flag = 1;
 226   3                              break;
 227   3                      }
 228   2              }
 229   1              return i;
 230   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1062    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.54   UART_TASK                                                             04/28/2017 13:06:00 PAGE 5   

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
